\documentclass[a4paper]{article}

\usepackage[per-mode=symbol,separate-uncertainty=true]{siunitx}
\usepackage{amsmath}
\usepackage{float}
\usepackage{graphicx}
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage{mathtools}
\usepackage{siunitx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage[dvipsnames]{xcolor}

\sisetup{exponent-product=\cdot}

\title{Integrated System Architecture \\ Lab session 1 report}
\author{Marco Andorno (247222)\\ Michele Caon (253027) \\ Matteo Perotti (251453) \\ Giuseppe Sarda (xxxxxx)}

\begin{document}
\maketitle

This report along with all the source files, scripts, reports and diagrams for the project can be found on GitHub at \url{https://github.com/mksoc/ISA-filter-design}.

\section{Filter design}
Following the rules given in the assignment, the main specifications were derived:
\begin{itemize}
    \item Filter type: IIR
    \item Filter order: \(N = 2\)
    \item Cutoff frequency: $f_c = \SI{2}{\kilo\hertz}$
    \item Sampling frequency: $f_s = \SI{10}{\kilo\hertz}$
    \item Data parallelism: $n_b = 12$
\end{itemize}
Then, using the provided example MATLAB script, the filter coefficients were found by means of the \texttt{butter} function. Real coefficients are then quantized as fixed point fractional number in the format $Q1.(n_b-1)$ ($Q1.11$ in our case) and expressed as integers on $n_b$ bits for the future C model and hardware filter. We will discover later that some care has to be taken when performing operations on the integer representation of fixed point numbers. 

Quantization is performed by truncation (\texttt{floor} function), so that the maximum error is equal to:
\begin{equation}\label{eq:emax}
    \varepsilon_{max} = 2^{-(n_b-1)} = 2^{-11} = 0.049\%
\end{equation}
We accept that this error could be reduced by rounding and that truncation introduces a negative bias by approximating always towards \(-\infty\), because on the other hand truncation is much easier to implement in hardware, where it just represent an arithmetic shift.

The resulting difference equation is in the end:
\[y[n] = b_0x[n] + b_1x[n-1] + b_2x[n-2] - a_1y[n-1] - a_2y[n-2]\]
where
\begin{description}
    \item \(b_0 = 0.20654 = 423\)
    \item \(b_1 = 0.41309 = 846\)
    \item \(b_2 = 0.20654 = 423\)
    \item \(a_1 = -0.36963 = -757\)
    \item \(a_2 = 0.19580 = 401\)
\end{description}

\begin{figure}[hbtp]
    \centering
    \includegraphics[width=.75\linewidth]{media/tf.pdf}
    \caption{Bode plot of the filter frequency response}
    \label{fig:tf}
\end{figure}
Figure~\ref{fig:tf} shows the transfer function of the filter computed from both the original coefficients and the quantized ones. The two curves cannot be told apart because the error is too small (\num{5.42e-7} in the worst case).

\begin{figure}[hbtp]
    \centering
    \includegraphics[width=.8\linewidth]{media/sine.pdf}
    \caption{Input and output waveforms}
    \label{fig:sine}
\end{figure}
Figure~\ref{fig:sine} on the other hand shows the time domain waveforms of an input signal $x_1(t)$, in blue, containing two frequency components one in band and one out of band, and the corresponding output $x_2(t)$, in red, where only the in-band component survives.

\section{Fixed-point C model}
The next step consists of writing a software model of the filter in C, which mirrors the behavior of the hardware architecture to be designed next. In this regard, the main difference between the MATLAB model and this one is that the former uses quantized coefficients but performs the internal computation using the maximum precision allowed by the machine, while the latter performs computation always resorting to the original fixed parallelism of data (12 bits here).

The development of this software model started with the example provided in the assignment, tailored to our specifications. A \href{https://github.com/mksoc/ISA-filter-design/blob/master/common/compare-outputs.py}{Python script} was developed and used to compare the results file of the two models. As expected, the comparison shows that the two models differ at most of one unity, that is the previously computed $\varepsilon_{max}$ (\ref{eq:emax}) in fractional form. Furthermore, results from the MATLAB model, when different, are always greater than the results from the C model, as the latter performs multiple truncations (rounding towards $-\infty$) in its computations. 

\section{Base architecture design}
The development of the first architecture began with the definition of the Data Flow Graph of the filter, shown in figure~\ref{fig:base_dfg}, from which the number of hardware resources needed can be derived (i.e. two delay elements, four adders and five multipliers).

\begin{figure}[hbtp]
    \centering
    \includegraphics[width=.8\linewidth]{media/base_dfg.pdf}
    \caption{DFG of the filter}
    \label{fig:base_dfg}
\end{figure}

\subsection{Datapath}
% BUG!!!! output register in the scheme is called reg_in instead of reg_out
From the generic DFG, a full datapath architecture was designed, shown in figure~\ref{fig:base_dp}. Compared to the simple DFG of figure~\ref{fig:base_dfg}, this datapath explicitly shows all signal names used throughout the design and their parallelism, along with additional interface registers required by the specifications. The following paragraphs detail the key points of the design. 

\begin{figure}[hbtp]
    \centering
    \includegraphics[width=\linewidth]{media/base_dp.pdf}
    \caption{Datapath}
    \label{fig:base_dp}
\end{figure}

\subsubsection{Color legend}
All datapath schemes used in this report follow the same color coding:
\begin{itemize}
    \item \textcolor{blue}{Blue} signals are data signals
    \item \textcolor{ForestGreen}{Green} signals are external coefficients
    \item \textcolor{Plum}{Purple} labels define the parallelism of the corresponding signal
    \item \textcolor{orange}{Orange} signals are control signals coming from the Control Unit
\end{itemize}

\subsubsection{Registers}
In addition to the two core delay elements of the filter DFG, the complete datapath includes also border registers for each piece of data coming in or out of the architecture, specifically the input and output sample stream and all filter coefficients. Input registers for the latter are not actually shown in figure~\ref{fig:base_dp} to avoid too much visual clutter, but assume that each coefficient in green is actually the output of a register.

Each register has implicit clock and asynchronous reset signals, as well as individual enable signals. No synchronous clear is provided as it is of no use for the purposes of this design.

\subsubsection{Arithmetic operators}
As per specifications, 


\end{document} 