\documentclass[a4paper]{article}

\usepackage[per-mode=symbol,separate-uncertainty=true]{siunitx}
\usepackage{amsmath}
\usepackage{float}
\usepackage{graphicx}
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage{mathtools}
\usepackage{siunitx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage[dvipsnames]{xcolor}

\sisetup{exponent-product=\cdot}

\title{Integrated System Architecture \\ Lab session 1 report}
\author{Marco Andorno (247222)\\ Michele Caon (253027) \\ Matteo Perotti (251453) \\ Giuseppe Sarda (xxxxxx)}

\begin{document}
\maketitle

This report along with all the source files, scripts, reports and diagrams for the project can be found on GitHub at \url{https://github.com/mksoc/ISA-filter-design}.
\tableofcontents

\section{Filter design}
Following the rules given in the assignment, the main specifications were derived:
\begin{itemize}
    \item Filter type: IIR
    \item Filter order: \(N = 2\)
    \item Cutoff frequency: $f_c = \SI{2}{\kilo\hertz}$
    \item Sampling frequency: $f_s = \SI{10}{\kilo\hertz}$
    \item Data parallelism: $n_b = 12$
\end{itemize}
Then, using the provided example MATLAB script, the filter coefficients were found by means of the \texttt{butter} function. Real coefficients are then quantized as fixed point fractional number in the format $Q1.(n_b-1)$ ($Q1.11$ in our case) and expressed as integers on $n_b$ bits for the future C model and hardware filter. We will discover later that some care has to be taken when performing operations on the integer representation of fixed point numbers. 

Quantization is performed by truncation (\texttt{floor} function), so that the maximum error is equal to:
\begin{equation}\label{eq:emax}
    \varepsilon_{max} = 2^{-(n_b-1)} = 2^{-11} = 0.049\%
\end{equation}
We accept that this error could be reduced by rounding and that truncation introduces a negative bias by approximating always towards \(-\infty\), because on the other hand truncation is much easier to implement in hardware, where it just represent an arithmetic shift.

The resulting difference equation is in the end:
\[y[n] = b_0x[n] + b_1x[n-1] + b_2x[n-2] - a_1y[n-1] - a_2y[n-2]\]
where
\begin{description}
    \item \(b_0 = 0.20654 = 423\)
    \item \(b_1 = 0.41309 = 846\)
    \item \(b_2 = 0.20654 = 423\)
    \item \(a_1 = -0.36963 = -757\)
    \item \(a_2 = 0.19580 = 401\)
\end{description}

\begin{figure}[hbtp]
    \centering
    \includegraphics[width=.75\linewidth]{media/tf.pdf}
    \caption{Bode plot of the filter frequency response}
    \label{fig:tf}
\end{figure}
Figure~\ref{fig:tf} shows the transfer function of the filter computed from both the original coefficients and the quantized ones. The two curves cannot be told apart because the error is too small (\num{5.42e-7} in the worst case).

\begin{figure}[hbtp]
    \centering
    \includegraphics[width=.8\linewidth]{media/sine.pdf}
    \caption{Input and output waveforms}
    \label{fig:sine}
\end{figure}
Figure~\ref{fig:sine} on the other hand shows the time domain waveforms of an input signal $x_1(t)$, in blue, containing two frequency components one in band and one out of band, and the corresponding output $x_2(t)$, in red, where only the in-band component survives.

\section{Fixed-point C model}
The next step consists of writing a software model of the filter in C, which mirrors the behavior of the hardware architecture to be designed next. In this regard, the main difference between the MATLAB model and this one is that the former uses quantized coefficients but performs the internal computation using the maximum precision allowed by the machine, while the latter performs computation always resorting to the original fixed parallelism of data (12 bits here).

The development of this software model started with the example provided in the assignment, tailored to our specifications. A \href{https://github.com/mksoc/ISA-filter-design/blob/master/common/compare-outputs.py}{Python script} was developed and used to compare the results file of the two models. As expected, the comparison shows that the two models differ at most of one unity, that is the previously computed $\varepsilon_{max}$ (\ref{eq:emax}) in fractional form. Furthermore, results from the MATLAB model, when different, are always greater than the results from the C model, as the latter performs multiple truncations (rounding towards $-\infty$) in its computations. 

\section{Base architecture design}
The development of the first architecture began with the definition of the Data Flow Graph of the filter, shown in figure~\ref{fig:base_dfg}, from which the number of hardware resources needed can be derived (i.e. two delay elements, four adders and five multipliers).

\begin{figure}[hbtp]
    \centering
    \includegraphics[width=.8\linewidth]{media/base_dfg.pdf}
    \caption{DFG of the filter}
    \label{fig:base_dfg}
\end{figure}

\subsection{Datapath}
% BUG!!!! output register in the scheme is called reg_in instead of reg_out
From the generic DFG, a full datapath architecture was designed, shown in figure~\ref{fig:base_dp}. Compared to the simple DFG of figure~\ref{fig:base_dfg}, this datapath explicitly shows all signal names used throughout the design and their parallelism, along with additional interface registers required by the specifications. The following paragraphs detail the key points of the design. 

\begin{figure}[hbtp]
    \centering
    \makebox[\textwidth][c]{\includegraphics[width=1.25\linewidth]{media/base_dp.pdf}}
    \caption{Datapath}
    \label{fig:base_dp}
\end{figure}

\subsubsection{Color legend}
All datapath schemes used in this report follow the same color coding:
\begin{itemize}
    \item \textcolor{blue}{Blue} signals are data signals
    \item \textcolor{ForestGreen}{Green} signals are external coefficients
    \item \textcolor{Plum}{Purple} labels define the parallelism of the corresponding signal
    \item \textcolor{orange}{Orange} signals are control signals coming from the Control Unit
\end{itemize}

\subsubsection{Registers}
In addition to the two core delay elements of the filter DFG, the complete datapath includes also border registers for each piece of data coming in or out of the architecture, specifically the input and output sample stream and all filter coefficients. Input registers for the latter are not actually shown in figure~\ref{fig:base_dp} to avoid too much visual clutter, but assume that each coefficient in green is actually the output of a register.

Each register has implicit clock and asynchronous reset signals, as well as individual enable signals. No synchronous clear is provided as it is of no use for the purposes of this design.

\subsubsection{Arithmetic operators}
As per specifications, arithmetic operators at this stage of the design are described as behavioral operators in VHDL. While no rounding is requested after addition, each multiplication must truncate back to the original number of bits, a VHDL package was written, containing a function called \texttt{multiplyAndRound} which performs potential sign extension of the operands, behavioral multiplication and truncation. In the same package, some constants and custom data types to make the design parametric were defined as well.

Addition is more easily implemented as simply the behavioral operator `$+$', but the fact that addition can overflow and need an additional bit on the output posed the need for some considerations about internal parallelism. By performing an analysis on the specific values of filter coefficients and the range of data stream values, the conclusion was that the maximum internal parallelism that this specific architecture can need is: $$n_b+1 = \SI{13}{bit}$$

Contrary to the initial expectations however, the output value $y$ was found to need $(n_b+1)$ bits as well because of occasional overflow, while in the beginning it was expected to stay in the $n_b$ range. Overflow on the output would of course cause very large errors in the result because of wrapping. So it was decided to implement a saturation approach which limits the error instead, by taking the maximum or minimum value allowed on $n_b$ bits if the actual results is too large or too small to be represented correctly.

This decision led to the need of modifying the fixed-point C model as well, to provide the same results of the VHDL description to compare during simulation and testing.

\subsection{Control unit}
Given the simplicity of the design, it was initially thought that no explicit control unit would be needed. While it is actually possible to avoid it completely, some considerations about the ease of extending the design with subsequent transformations and pipelining (section~\ref{sec:improv}) as well as the preference for modularity and clarity led to the decision to implement a simple control unit, which FSM is shown in figure~\ref{fig:fsm}.

\begin{figure}[hbtp]
    \centering
    \includegraphics[width=.5\linewidth]{media/fsm.pdf}
    \caption{Filter control unit FSM}
    \label{fig:fsm}
\end{figure}

This control unit satisfies the specifications about the generation of the signal \texttt{vOut} to notify the presence of new data at the output and the need to take into account possible pauses during the input data stream. In practice, figure~\ref{fig:timing} shows the timing diagram that this FSM implements.

\begin{figure}[hbtp]
    \centering
    \makebox[\textwidth][c]{\includegraphics[width=1.25\linewidth]{media/timing.pdf}}
    \caption{Timing diagram}
    \label{fig:timing}
\end{figure}

\subsection{Simulation}
All simulations were performed using ModelSim both on our local machines and on the remote server, by means of a mixed-language testbench partly already provided in the course material. The procedure and tools described in the following sections apply to the simulation of all the RTL description as well as the netlists generated by other tools used for synthesis or place and route.

Each design or netlist has been simulated extensively multiple times using up to 100000 samples generated randomly or with special values, which would normally take around 20 minutes.

Regarding the simulation of the RTL description, no particular problems arose apart from the usual initial debugging and in the end the design worked as expected.

\subsubsection{Testbench}
The testbench is made up of several independent modules:
\begin{itemize}
    \item A \emph{clock generator} in charge of generating the initial reset signal and a periodic clock of specified period until an external \texttt{end\_sim} signal arrives to notify the end of the simulation. This is useful to automatically stop the simulation process when all input data has been processed instead of fixing a specific time span a priori.
    \item A \emph{data maker} which reads input data from a text file, converts it to a suitable format (\texttt{signed} in this case) and feeds it to the hardware description of the filter. It also allows to insert pauses in between samples to verify that such situation is handled correctly by the design. The number of pauses can be hard-coded or random, according to the value of a constant defined in the package.
    \item A \emph{data sink} to read output data stream from the hardware block and write it to another text file.
    \item A top module written in Verilog (instead of VHDL as the previous ones) that simply connects the instance of the filter and all other testbench modules together. The need to describe this block in Verilog arises from the fact that synthesis and place and route tools generate Verilog netlists and are more comfortable using Verilog files.
\end{itemize}

\subsubsection{Scripts}
In order to try to automate as much as possible the simulation process, a number of scripts were developed, which can be found in the GitHub repository or in the material provided:
\begin{itemize}
    \item \texttt{samples-generator.py} to generate a user-specified number of samples either random or special (meaning extremes and zero only).
    \item \texttt{auto-scp.sh} to automate the copy of source files and input samples on the server and results and netlists from the server.
    \item \texttt{compare-results.py} which compares the results of the simulation against the ones produced by the C model (figure~\ref{fig:yeee}).
    \item \texttt{auto-simulate.sh} which allows, by means of defining environmental variables, to choose whether to simulate locally or remotely and which design to simulate (RTL description, post-synthesis netlist or post-place and route netlist) and then performs several steps to automatically carry out the simulation, namely:
    \begin{itemize}
        \item Generates samples using \texttt{samples-generator.py}.
        \item Runs the C model on these samples.
        \item Connects to the server (if the user has chose to run the simulation remotely) and copies the samples file.
        \item Runs ModelSim CLI to perform the simulation.
        \item Retrieves output files and compare the results.
    \end{itemize}
    \item \texttt{sim-script.tcl} executed directly by ModelSim, which reads the environmental variables passed by \texttt{auto-simulate.sh} and issues the correct commands to the tool.
\end{itemize}

\begin{figure}[hbtp]
    \centering
    \includegraphics[width=.8\linewidth]{media/2018-12-20-143134_627x116_scrot.png}
    \caption{Successful comparison}
    \label{fig:yeee}
\end{figure}

\subsection{Synthesis}
The synthesis of the design has been carried out using Synopsys Design Compiler, following the instructions given in the specifications. All the commands issued to the tool were again put together inside a TCL script to ease the repetition of the process. 

At first try, the comparison between the synthesized design and the original RTL description resulted in outputs being completely different. After some trial and error, which included confrontation with colleagues and Professors, the issue came out to be the issuing of asynchronous reset signal in the first state of the control unit to all registers. The solution was to remove those outputs from such state and instead wire up the reset of the register directly to the external reset signal, which rendered the initial state of the control unit an empty idle state, as seen in the final FSM of figure~\ref{fig:fsm}.

After successfully completing the synthesis and testing the correctness of the results from the netlist, the figures of merit in terms of maximum frequency, power and area resulted to be the ones shown in table~\ref{tab:base_post_syn}.

\begin{table}[hbtp]
    \centering
    \begin{tabular}{|l|l|}
    \hline
    $f_{max}$     & $\SI{314.7}{MHz}$              \\ \hline
    Area          & $\SI{4742.51}{\micro\meter^2}$ \\ \hline
    Dynamic power & $\SI{526.86}{\micro\watt}$     \\ \hline
    Static power  & $\SI{81.55}{\micro\watt}$      \\ \hline
    \end{tabular}
    \caption{Figures of merit post-synthesis. Power was computed at $f_{max}/4 = \SI{89.3}{MHz}$ as per laboratory guidelines.}
    \label{tab:base_post_syn}
\end{table}

\subsection{Place \& route}
The place and route phase was carried out using Cadence Innovus and the instructions provided in the lab track. As always, a script was put together to collect all commands issued to the tool, even if it was more difficult in this case as the GUI was heavily used. 

All the place and route was done using a clock frequency equal to a quarter of the maximum one found during synthesis. The results are shown in table~\ref{tab:base_post_pnr}.

\begin{table}[hbtp]
    \centering
    \begin{tabular}{|l|l|}
    \hline
    Area          & $\SI{3919.2}{\micro\meter^2}$   \\ \hline
    Dynamic power & $\SI{1599}{\micro\watt}$        \\ \hline
    Static power  & $\SI{79.4}{\micro\watt}$        \\ \hline
    \end{tabular}
    \caption{Figures of merit post-place \& route. Both area and power were computed at $f_{max}/4 = \SI{89.3}{MHz}$ as per laboratory guidelines.}
    \label{tab:base_post_pnr}
\end{table}

By comparing tables~\ref{tab:base_post_syn} and~\ref{tab:base_post_pnr}, it is evident that results do not agree very much, apart from the static power. In terms of area this is due to the fact that the place and route was carried out at a much lower frequency while the area given by the synthesis refers to the maximum frequency achievable: this means that Design Compiler must have instantiated different hardware components in the two cases, the slower ones having also smaller area. 

Regarding dynamic power on the other hand, the first thing that comes to mind is that Innovus certainly has a better estimation of the actual interconnects and their dissipated power. This however cannot be the only explanation, because comparing more closely the power reports from the two tools, both the internal power and the net switching power increase dramatically in the case of place and route. \textcolor{red}{SO WTF??}.

\end{document} 